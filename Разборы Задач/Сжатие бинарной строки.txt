СЖАТИЕ БИНАРНОЙ СТРОКИ

Нам дана строка, состоящая из m нулей и n единиц (например, 1001).
Генерируем все комбинации из m нулей и n единиц (в порядке возрастания, т.е. лексикографическом).
В данном примере: 0011, 0101, 0110, 1001, 1010, 1100.
В ответ выводим номер входной строке в последовательности сгенерированных комбинаций. (нумерация с 0)(т.е. в данном случае число 3 в двоичном виде).

Пример из условия:
Входная строка:
00000001101111111111111111111111
Комбинации:
00000000111111111111111111111111 - номер 0
00000001011111111111111111111111 - номер 1
00000001101111111111111111111111 - номер 2(является входной строкой)
00000001110111111111111111111111 - номер 3
....
11111111111111111111111100000000 - номер какой-то там

В ответ выводим число 2 в двоичной системе (10). В условии написано, что "ведущие нули при этом можно опустить". Не знаю, зачем в ответе в условии написали столько нулей слева.

А как мы будем эти комбинации генерировать-то? Можно, конечно, пробежаться по всем двоичным числам нужной разрядности и выбрать среди них подходящие, но это медленно. 

На самом деле можно получить ответ таким образом:
1) Бежим по всем единицам строки справа налево
2) Для каждой единицы считаем количество перестановок C из n по k, где:
n - кол-во цифр справа от текущей
k - кол-во единиц справа от текущей, считая текущую цифру (если она является единицей, конечно же).
Формула перестановок: C(n,k) = n!/((n-k)!*k!)
Пример:
1001
цифра с номером 4: C(0,1) = 0
цифра с номером 1: C(3,2) = 3
Ответ = 0 + 3 = 3. Всё сходится.


Есть ещё крутая оптимизация. Поскольку каждый раз считать факториал долго, мы выражаем значение C для i-го элемента черещ i+1 - й:
С(n+1, k) = C(n, k)*(n+1)/(n+1-k) (для нулей)
С(n+1, k+1) = C(n, k)*(n+1)/(k+1) (для единиц)

Код итогового решения на Python:

import math

with open ('input.txt') as fin:
    tn, tm = [int(t) for t in next(fin).split()]
    s = fin.readline()
res = 0
curres = 0
prevres = 0
k = 0
was_non_zero_c = False
for i in range(len(s)-1,-1,-1):
    n = len(s)-1 - i
    if s[i] == '1': k += 1
    if (n < k): continue
    if (not was_non_zero_c):
        curres = int(int(math.factorial(n)) // int((math.factorial(n - k)) * int(math.factorial(k))))
        if (curres != 0): was_non_zero_c = True
    else:
        if ((n + 1 - k == 0) and (s[i] == '0')) or ((k + 1 == 0) and (s[i] == '1')):
            curres = 0
        else:
            if (s[i] == '1'):
                curres = int(prevres * int(n) // int(k))
            else:
                curres = int(prevres * int(n) // int(n - k))
    if s[i] == '1':
        res += curres
    prevres = curres
with open('output.txt', 'w') as fout:
    fout.write(bin(res)[2:])